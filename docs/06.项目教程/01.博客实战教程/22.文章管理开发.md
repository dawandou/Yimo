---
title: 文章管理开发
date: 2022-10-31 14:38:54
permalink: /pages/f8a231/
categories: 
  - 项目教程
  - 博客实战教程
tags: 
  - 
---

# 前言
时隔三四个月了没更新了，差一点烂尾了，对不住各位小伙伴了现在才更新，这也是我们这个教程的最后一篇了，接下来可能还会更新一下项目的上线功能，大概会用一到两篇的文章写完，可能需要服务器，大家如果有条件的话还是要去搞一台自己的服务器，模拟真实的线上环境才能更好的学习，可以去拼夕夕买或者百度云也可以都挺便宜，四五十块钱就可以了，还是希望大家用真实的环境来学习。

最近我打算写redis的学习，各位小伙伴有需要的话可以去我的Redis从入门到实战专栏查看，有什么好的意见可以评论区告诉我或者加我好友沟通，


# 1、添加文章的页面
首先我们还是按照之前分类或标签的操作来写页面，我们在前端项目中新建两个文件，一个是add.vue，一个是list.vue。我们先从添加页面入手。

添加文章的业务比较复杂一些，因为里面包含了标签和分类的功能查询和保存，还涉及到图片的保存，所以比较重要，里面的知识点也比较多，我尽量将讲述清楚，大家也多多思考，有不会的可以关注下面的微信号，加我好友来一起讨论学习。

我们接下来先来写添加文章，打开前端项目，然后我们在/src/views/articles下的add.vue编写。

还是和之前添加标签或分类的一样，使用的mavon-editor编辑。


## 1.1、基础页面编写
我们可以将分类的页面复制过来进行修改，或者自己来手动写一遍，建议自己写一遍，了解具体的编写思路。
```vue
<template>
    <el-card class="box-card">
    <!-- 设置文章管理 -->
    <div slot="header" class="clearfix">
      <span>添加文章</span>
    </div>

    <!-- 发布文章 -->
    <div class="article-title-container">
        <el-input size="medium"  v-model="article.title" placeholder="输入文章标题"/>
        <el-button type="warning" size="medium" @click="openDialog" style="margin-left:10px">保存草稿</el-button>
        <el-button type="danger" size="medium" @click="openDialog" style="margin-left:10px">发布文章</el-button>
    </div>
    <!-- 文章内容 -->
    <mavon-editor ref="md" v-model="article.content" style="height:calc(100vh - 260px)"/>

    <!-- 填写信息弹出框 -->
    <el-dialog :title="`发布文章：${article.title}`" :visible.sync="showDialog" width="30%">


      <el-form label-position="left" label-width="80px" :model="article" size="medium">
       
        <!-- 内容 -->  
      
      </el-form>

       <span slot="footer">
        <el-button @click="handleCancel">取 消</el-button>
        <el-button type="primary" @click="handleSubmit">发布</el-button>
      </span>
    </el-dialog>


 </el-card>
</template>

<script>
import { addArticle, updateArticle, getArticleById } from '@/api/article'


export default {
  name: 'Addarticle',

  created() {
    
  },

   data() {
    return {
      showDialog: false,
     
      article: {
        id: "",
        title: "",
        categoryId: "",
        content: "",
        categoryName: null
      }
    }
  },

  methods: {

    assertNotEmpty(target, msg) {
      if (!target) {
        this.$message({
          message: msg,
          type: "warning",
        });
        return false;
      }
      return true;
    },

     // 打开文章信息填写框
    openDialog() {
      if (
        this.assertNotEmpty(this.article.title, "请填写文章标题") &&
        this.assertNotEmpty(this.article.content, "请填写文章内容")
      ) {
        this.showDialog = true;
      }
    },

    handleSubmit() {
        this.showDialog = true;
        var body = this.article;
    },
    
    handleCancel() {
      this.showDialog = false;
    },
  }
 
}
</script>

<style rel="stylesheet/scss" lang="scss" scoped>

.article-title-container {
  display: flex;
  align-items: center;
  margin-bottom: 1.25rem;
  margin-top: 1.25rem;
}

  .box-card {
    width: 98%;
    margin: 1%;
  }
  .clearfix:before,
  .clearfix:after {
    display: table;
    content: "";
  }
  .clearfix:after {
    clear: both
  }
  .clearfix span {
    font-weight: 600;
  }

</style>

```
以上的代码没有什么好介绍的了，我们已经写了好几遍了，如果有报错看一下浏览器控制台有什么错误，自己修改一下就好了。

![image.png](https://pic.zhaotu.me/2023/03/01/image3905921f5091fd7b.png)

**PS：如果左侧的导航栏没有显示这两个页面的话，你就去路由那边将这两个页面添加上即可。**

以上基础的页面已经搭建好了，我们要去完成数据交互的部分。


# 2、添加api接口
先来添加一下后端的接口，打开/src/api文件，如果没有article.js文件则自己创建一个，然后我们打开文件，和之前的都一样，我们写一下接口。
```vue
import request from '@/utils/request'

export function articleList(query) {
    return request({
      url: '/article/list',
      method: 'post',
      data: query
    })
}

export function addArticle(data) {
  return request({
    url: '/article/create',
    method: 'post',
    data
  })
}

export function updateArticle(data) {
  return request({
    url: '/article/update',
    method: 'post',
    data
  })
}

export function deleteArticle(id) {
  return request({
    url: '/article/delete',
    method: 'post',
    params: { id }
  })
}

export function getArticleById(id){
  return request({
    url: '/article/info/' + id,
    method: 'get'
  })
}
```
最后的一个接口根据id查找文章我忘了当时给没给你们写了，如果你没有写的话，将文章拉到最后，我已经更新到了仓库，前后端的项目都已经是最新的代码了。


# 3、添加功能
准备工作已经完成，接下来我们来写实现的功能，其实重点就是弹出框里的数据交互操作比较复杂一些。

## 3.1、引入接口
我们先将接口引入到我们的add.vue文件中。
```vue
import { addArticle, updateArticle, getArticleById } from '@/api/article'
```
这里我们还会用到分类的接口，我们也先将分类的接口引入过来。
```vue
import { } from '@/api/category'
```


## 3.2、添加分类查询接口
我们还要完善一下后端的接口，我们这里添加文章的弹框需要查询全部的分类，或者根据输入的分类去查找有没有分类可供选择，所以我们要去添加一个查询分类的接口。<br />打开后端项目，我们先添加一个查询参数的对象，方便以后管理。<br />1、在bo包中新建一个CategoryBO.java
```java
package com.blog.personalblog.bo;

import lombok.Data;

/**
* 分类查询条件
*
* @author: SuperMan
* @create: 2022-10-10
**/

@Data
    public class CategoryBO {

        /**
		 * 分类名称
        */
        private String categoryName;
    }
```
2、然后我们去写接口，直接在原来的CategoryService中添加个接口即可
```java
    /**
     * 搜索文章分类
     * @param bo
     * @return
     */
    List<Category> getCategoriesByName(CategoryBO bo);
```
3、数据查询mapper接口
```java
/**
     * 查询分类
     * @param bo
     * @return
     */
    List<Category> findCategoriesByName(CategoryBO bo);
```
4、实现分类数据库xml功能
```xml
 <select id="findCategoriesByName" parameterType="com.blog.personalblog.bo.CategoryBO" resultMap="BaseResultMap">
        select * from person_category
        <where>
            <if test="categoryName != null and companyName != ''">
                and category_name like #{companyName}
            </if>
        </where>
</select>
```
5、最后实现分类查询的实现类。
```xml
    @Override
    public List<Category> getCategoriesByName(CategoryBO bo) {
        List<Category> categoriesByName = categoryMapper.findCategoriesByName(bo);
        return categoriesByName;
    }
```
6、最后再写controller层
```java
    /**
     * 搜索文章分类
     * @param bo
     * @return
     */
    @ApiOperation(value = "查询分类名称")
    @PostMapping("/getCategory")
    @OperationLogSys(desc = "查询分类名称", operationType = OperationType.SELECT)
    public JsonResult<Object> getCategoryByName(@RequestBody @Valid CategoryBO bo) {
        List<Category> categoriesByName = categoryService.getCategoriesByName(bo);
        return JsonResult.success(categoriesByName);
    }
```
写完，我们要测试一下接口通不通再去页面上去接接口，养成好的习惯。

![image.png](https://pic.zhaotu.me/2023/03/01/image3c243b771ed072f2.png)

## 3.3、添加标签查询接口
接下来还要写标签的查询接口，文章涉及到东西比较多，基本上把之前做的都整合在了一起，这是我们整个项目的重点灵活。和上边分类差不多，我们再来写一下标签。

1、在bo包中新建一个CategoryBO.java

```java
package com.blog.personalblog.bo;

import lombok.Data;

/**
* @author: SuperMan
* @create: 2022-10-10
**/

@Data
    public class TagBO {

        /**
* 标签名称
*/
        private String tagName;
    }

```
2、然后写接口，在原来的TagService中添加个接口即可
```java
	/**
     * 搜索文章标签
     *
     * @param bo
     * @return
     */
    List<Tag> getTagsByTagName(TagBO bo);
```

3、数据查询mapper接口
```java
	/**
     * 查询文章标签
     * @param bo
     * @return
     */
    List<Tag> findTagsByTagName(TagBO bo);
```
4、实现标签数据库xml功能
```xml
  <select id="findTagsByTagName" parameterType="com.blog.personalblog.bo.TagBO" resultMap="BaseResultMap">
        select * from person_tag
        <where>
            <if test="tagName != null and tagName != ''">
                and tag_name like '%${tagName}%'
            </if>
        </where>
    </select>
```
5、最后实现分类查询的实现类。
```java
@Override
public List<Tag> getTagsByTagName(TagBO bo) {
   List<Tag> tagsByTagName = tagMapper.findTagsByTagName(bo);
   return tagsByTagName;
}
```
6、controller层
```java
/**
* 按条件查询文章标签
* @param bo
* @return
*/
	@ApiOperation(value = "查询文章标签")
    @PostMapping("/selectTag")
    @OperationLogSys(desc = "查询文章标签", operationType = OperationType.SELECT)
    public JsonResult<Object> getTagByTagName(@RequestBody @Valid TagBO bo) {
        List<Tag> tagsByTagName = tagService.getTagsByTagName(bo);
        return JsonResult.success(tagsByTagName);
    }
```
7、测试接口

![image.png](https://pic.zhaotu.me/2023/03/01/image9a9f9d8235a3a2ef.png)
## 3.4、编写添加文章页面弹出层

### 3.4.1、添加标签和分类查询接口
在/src/api文件下找到category.js接口，我们将刚才新添加的分类查询接口加入进来
```vue
export function getCategory(data) {
  return request({
    url: '/category/getCategory',
    method: 'post',
    data
  })
}
```
在/src/api文件下找到tag.js接口，我们将刚才新添加的标签查询接口加入进来
```vue
export function getTag(data) {
  return request({
    url: '/tag/selectTag',
    method: 'post',
    data
  })
}
```

### 3.4.2、添加文章分类功能
文章分类功能是在我们弹出框里，为了方便大家学习，我现将业务逻辑分析一下，然后再来写具体的代码，这样就能清晰的分析代码，进而读懂代码了。

**文章分类业务分析：**

首先我们写完文章之后，点击发布文章，然后跳出一个弹出框，需要我们填写文章的一些属性，我们先重点来说分类，然后标签就和这类似了。

![image.png](https://pic.zhaotu.me/2023/03/01/image3a9a65fe18c9c567.png)

上图是我点击发布文章之后弹出的，我们先设置一个添加分类的按钮，这时我们会触发查询分类的接口，将数据库中的所有分类全部查询出来。然后我们可以进行搜索或者自定义分类，使用了vue的el-autocomplete搜索框来实现。

- 搜索：当我们在输入框输入数据时，就会请求接口进行条件查询。
- 自定义：直接在输入框中输入完分类的名称之后，直接回车即可。

![image.png](https://pic.zhaotu.me/2023/03/01/imagef20c6d49d98b9e50.png)

接下来我们用代码进行分析。

这里主要是分析弹出框里面的内容。

当你选择完分类之后，会在页面上展示出来分类的名称。

```vue
<el-tag type="success" v-show="article.categoryName" style="margin:0 1rem 0 0" :closable="true" @close="removeCategory">
   {{ article.categoryName }}
</el-tag>
```
removeCategory()方法的实现：
```vue
removeCategory() {
      this.article.categoryName = null;
},
```
以下是选择分类的功能模块

- el-popover 是ElementUI封装的一个弹窗组件，类似于el-tooltip，弹窗中也可以自定义内容等。
- autocomplete 是一个可带输入建议的输入框组件，具体官方文档：[https://element.eleme.cn/#/zh-CN/component/input](https://element.eleme.cn/#/zh-CN/component/input)
```vue
        <!-- 分类选项 -->
           <el-popover placement="bottom-start" width="460" trigger="click" v-if="!article.categoryName">
            <div class="popover-title">分类</div>
            <!-- 搜索框 -->
            <el-autocomplete
              style="width:100%"
              v-model="categoryName"
              :fetch-suggestions="findCategories"
              placeholder="请输入分类名搜索，如果自定义分类，输入完成之后直接回车即可！"
              :trigger-on-focus="false"
              @keyup.enter.native="saveCategory"
              @select="handleFindCategories"
            >
              <template slot-scope="{ item }">
                <div>{{ item.categoryName }}</div>
              </template>
            </el-autocomplete>

            <!-- 分类数据展示 -->
            <div class="popover-container">
              <div class="category-item" v-for="item of categoryList" :key="item.id" @click="addCategory(item)">
                {{ item.categoryName }}
              </div>
            </div>
            <el-button type="success" plain slot="reference" size="small"> 添加分类 </el-button>

           </el-popover>
```
其余的也没什么好说的，大家看一下应该都能看懂，之前也讲过一部分，比如分类数据展示，就是个list数据的展示等操作。<br />js的部分主要实现一些方法的操作，这里我们还引入了分类的接口。后边还会引入标签的接口。
```vue
import { addArticle, updateArticle, getArticleById } from '@/api/article'
import { getCategory } from '@/api/category'


data() {
    return {
      showDialog: false,
      categoryName: "",
      categoryList: [],
      article: {
        id: "",
        title: "",
        categoryId: "",
        content: "",
        categoryName: null
      }
    }
  },

methods: {

     // 打开文章信息填写框
    openDialog() {
      if (this.article.title.trim() == "") {
        this.$message.error("文章标题为空，请填写文章标题");
        return false;
      }
      if (this.article.content.trim() == "") {
        this.$message.error("文章内容为空，请填写文章内容");
        return false;
      }
      this.getCategoriesList();
      this.showDialog = true;
    },

    //------分类的业务处理开始------
    getCategoriesList() {
      var categoryName = "";
      getCategory({categoryName}).then(response => {
         this.categoryList = response.data;
      })
    },
    removeCategory() {
      this.article.categoryName = null;
    },
    //搜索分类名称
    findCategories(categoryName, cb) {
       getCategory({categoryName}).then(response => {
         cb(response.data);
       })
    },
    saveCategory() {
      if (this.categoryName.trim() != "") {
        this.addCategory({
          categoryName: this.categoryName
        });
        this.categoryName = "";
      }
    },
    addCategory(item) {
      this.article.categoryName = item.categoryName;
    },
    handleFindCategories(item) {
      this.addCategory({
        categoryName: item.categoryName
      });
    },
  //------分类的业务处理结束------

handleSubmit() {
        this.showDialog = true;
        var body = this.article;
      
    },
    
    handleCancel() {
      this.showDialog = false;
    },
  }


//css
.popover-title {
    margin-bottom: 1rem;
    text-align: center;
  }
  .category-item {
    cursor: pointer;
    padding: 0.6rem 0.5rem;
  }
  .category-item:hover {
    background-color: #f0f9eb;
    color: #67c23a;
  }
```
具体的代码我会将放在这一节的最后展示，大家先进行学习，有错误了再去对照完整的代码看一下。

### 3.4.3、添加文章标签功能
标签的功能和分类的功能差不多，大家可以先自己参照分类的思路先写，然后再接着往下看我写的作为参考，这样自己就能再脑子里回顾一下写的思路，以后写项目遇到类似的功能就能非常清楚的想起思路。<br />这里我先将标签的主要代码列举出来，基本上和分类的一致，但是分类只有一个，标签有多个，前端限制的每一篇文章最多只有三个。
```vue
 <!-- ----------文章标签开始---------- -->
        <el-form-item label="文章标签">
          <el-tag
            v-for="(item, index) of article.tagNameList"
            :key="index"
            style="margin:0 1rem 0 0"
            :closable="true"
            @close="removeTag(item)"
          >
            {{ item }}
          </el-tag>
          <!-- 标签选项 -->
          <el-popover
            placement="bottom-start"
            width="460"
            trigger="click"
            v-if="article.tagNameList.length < 3"
          >
            <div class="popover-title">标签</div>
            <!-- 标签搜索框 -->
            <el-autocomplete
              style="width:100%"
              v-model="tagName"
              :fetch-suggestions="findTags"
              placeholder="请输入标签名搜索，按回车可添加自定义标签"
              :trigger-on-focus="false"
              @keyup.enter.native="saveTag"
              @select="handleFindTag"
            >
              <template slot-scope="{ item }">
                <div>{{ item.tagName }}</div>
              </template>
            </el-autocomplete>

            <!-- 标签数据展示 -->
            <div class="popover-container">
              <div style="margin-bottom:1rem">添加标签</div>
              <el-tag
                v-for="(item, index) of tagList"
                :key="index"
                :class="tagClass(item)"
                @click.native="addTag(item)"
              >
                {{ item.tagName }}
              </el-tag>
            </div>
            <el-button type="primary" plain slot="reference" size="small">
              添加标签
            </el-button>
          </el-popover>
        </el-form-item>

        <!-- ----------文章标签结束---------- -->
```
JS部分：
```vue
import { getTag } from '@/api/tag'

  //------标签的业务处理------
    getTagsList() {
      var tagName = "";
      getTag({tagName}).then(response => {
         this.tagList = response.data;
      })
    },
   
    //搜索标签名称
    findTags(tagName, cb) {
       getTag({tagName}).then(response => {
         cb(response.data);
       })
    },
    handleFindTag(item) {
      this.addTag({
        tagName: item.tagName
      });
    },
    saveTag() {
      if (this.tagName.trim() != "") {
        this.addTag({
          tagName: this.tagName
        });
        this.tagName = "";
      }
    },
   
    addTag(item) {
      console.log("标签展示：",item);
      if (this.article.tagNameList.indexOf(item.tagName) == -1) {
        this.article.tagNameList.push(item.tagName);
      }
    },
    removeTag(item) {
      const index = this.article.tagNameList.indexOf(item);
      this.article.tagNameList.splice(index, 1);
    },
  //------标签的业务处理结束------
  
//放到methods方法外层
computed: {
    tagClass() {
      return function(item) {
        const index = this.article.tagNameList.indexOf(item.tagName);
        return index != -1 ? "tag-item-select" : "tag-item";
      };
    }
  }
```
这里我只说一个知识点：

**问题：vue中@click和@click.native.prevent的区别是什么？**

- @click是用在按钮上的语法
- @click.native是给vue组件绑定事件时候，必须加上native ，否则会认为监听的是来自Item组件自定义的事件，prevent是用来阻止默认的事件。就相当于&hellip;event.preventDefault()，父组件想在子组件上监听自己的click的话，需要加上native修饰符。

 ![image.png](https://pic.zhaotu.me/2023/03/01/image9050eefd440b1177.png)

### 3.4.4、文章摘要
文章摘要也就是对文章的大体描述功能，这个就是个表单，没有难点。
```vue
<el-form-item label="文章摘要">
    <el-input type="textarea" :rows="2" placeholder="请输入内容" v-model="article.description" style="width:220px" />
</el-form-item>

return {
      showDialog: false,
      categoryName: "",
      categoryList: [],
      tagName: "",
      tagList: [],
      article: {
        id: "",
        title: "",
        categoryId: "",
        content: "",
        categoryName: null,
        tagNameList: [],
        description: ""
      }
    }
```

### 3.4.5、文章封面上传
文章封面上传功能是一个新的知识点，我们后端要添加新的接口，上传图片的接口，这里就涉及到文件的上传，保存路径等操作，这也是在以后的工作中经常使用的文件操作，这个也是一个重点，希望大家认真对待学习。

我们先去写后端图片上传的功能，图片的存储等操作。希望大家能了解图片上传的业务逻辑思路。

**1、后端功能**

和之前的业务流程一样，我们先写一个图片上传的接口，打开ArticleService.java   

```java
	/**
     * 上传文件
     *
     * @param file
     * @return
     */
    String uploadFile(MultipartFile file);
```
这里说一下MultipartFile对象，有些同学可能没有学过或不了解，我这里简单的说明一下。

使用MultipartFile这个类主要是来实现以表单的形式进行文件上传功能。首先MultipartFile是一个接口，并继承自InputStreamSource，且在InputStreamSource接口中封装了getInputStream方法，该方法的返回类型为InputStream类型，这也就是为什么MultipartFile文件可以转换为输入流。通过以下代码即可将MultipartFile格式的文件转换为输入流。

这个MultipartFile有一些常用的方法。

- **getName**

getName方法获取的是前后端约定的传入文件的参数的名称，在SpringBoot后台中则是通过		@Param("uploadFile") 注解定义的内容。

- **getOriginalFileName**

getOriginalFileName方法获取的是文件的完整名称，包括**文件名称+文件拓展名**。

- **getContentType**

getContentType方法获取的是文件的类型，注意是文件的类型，不是文件的拓展名。

- **getSize**

getSize方法用来获取文件的大小，单位是字节。

- **getInputStream**

getInputStream方法用来将文件转换成输入流的形式来传输文件，会抛出IOException异常。

还有一些其他的方法，大家可以自己去查找，以上这些我们会经常用到。

接口有了，我们再去写实现方法，打开ArticleServiceImpl.java实现类。

通过上边对MultipartFile的解释，下面我们就使用到了。

```java
	@Override
    public String uploadFile(MultipartFile file) {
        try {
            // 获取文件md5值
            String md5 = FileUtils.getMd5(file.getInputStream());
            // 获取文件扩展名
            String extName = FileUtils.getExtName(file.getOriginalFilename());
            // 重新生成文件名
            String fileName = md5 + extName;
            // 判断文件是否已存在
            if (!exists(ARTICLE + fileName)) {
                // 不存在则继续上传
                upload(ARTICLE, fileName, file.getInputStream());
            }

            // 返回文件访问路径
            return getFileAccessUrl(ARTICLE + fileName);

        } catch (Exception e) {
            e.printStackTrace();
            log.error("文件上传失败");
        }
        return null;
    }
```

1. 首先我们拿到上传的图片之后，我们先进行MD5然后拿到文件的MD5值进行图片文件名重新命名，为的就是防止文件名重复，被覆盖，就会导致图片数据丢失。
2. 然后通过getOriginalFilename获取图片的后缀格式。
3. 拼接起来组成新的图片名称。
4. 为了防止丢失数据，再次进行图片名称判断，有就直接返回地址，没有则继续上传图片或文件。

以上会用到几个方法和工具类如下：

**FileUtils工具类：**

```java
package com.blog.personalblog.util;

import cn.hutool.core.util.StrUtil;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.codec.binary.Hex;
import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;

/**
 * 文件md5工具类
 *
 */
@Log4j2
public class FileUtils {

    /**
     * 获取文件md5值
     *
     * @param inputStream 文件输入流
     * @return {@link String} 文件md5值
     */
    public static String getMd5(InputStream inputStream) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("md5");
            byte[] buffer = new byte[8192];
            int length;
            while ((length = inputStream.read(buffer)) != -1) {
                md5.update(buffer, 0, length);
            }
            return new String(Hex.encodeHex(md5.digest()));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 得到文件扩展名
     *
     * @param fileName 文件名称
     * @return {@link String} 文件后缀
     */
    public static String getExtName(String fileName) {
        if (StrUtil.isBlank(fileName)) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf("."));
    }

}

```
**exists方法：**

**本地路径需要在配置文件中配置，打开application.yml配置文件，然后配置如下：**

```java
upload:
  local:
    path: /blog/uploadFile/
    url: http://localhost:9090/blog
```
```java
	/**
     * 本地路径
     */
    @Value("${upload.local.path}")
    private String localPath;

	/**
     * 访问url
     */
    @Value("${upload.local.url}")
    private String localUrl;

    private static final String ARTICLE = "articles/";


	/**
     * 判断文件是否存在
     *
     * @param filePath 文件路径
     * @return
     */
    public Boolean exists(String filePath){
        return new File(localPath + filePath).exists();
    }
```
**getFileAccessUrl方法：**
```java
    /**
     * 获取文件访问url
     *
     * @param filePath 文件路径
     * @return
     */
    public String getFileAccessUrl(String filePath) {
        return localUrl + localPath + filePath;
    }
```
**upload方法：**
```
private void upload(String path, String fileName, InputStream inputStream) throws IOException {
    File directory = new File(localPath + path);
    if (!directory.exists()) {
        if (!directory.mkdirs()) {
            log.error("创建目录失败");
        }
    }
    // 写入文件
    File file = new File(localPath + path + fileName);
    if (file.createNewFile()) {
        BufferedInputStream bis = new BufferedInputStream(inputStream);
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));
        byte[] bytes = new byte[1024];
        int length;
        while ((length = bis.read(bytes)) != -1) {
            bos.write(bytes, 0, length);
        }
        bos.flush();
        inputStream.close();
        bis.close();
        bos.close();
    }
}
```
然后我们在去写controller层接口，打开ArticleController.java，这个就不要记日志了，我们日志那边没有做文件的处理，所以会报错，这里暂时不需要记日志。
```java
	/**
     * 上传网站logo封面
     * @param file
     * @return 返回logo地址
     */
    @ApiOperation(value = "上传网站logo封面")
    @PostMapping("upload")
    public JsonResult<String> uploadImg(@RequestParam(value = "file") MultipartFile file) {
        String s = articleService.uploadFile(file);
        return JsonResult.success(s);
    }
```
好了，上传图片的功能已经实现，我们接下来用postman测试一下。

![image.png](https://pic.zhaotu.me/2023/03/01/image989b92b821f41bf5.png)

这时我们请求接口会报500错误，我们再看一下后端有没有报错信息。果然也报错了，需要我们去设置一下文件上传的大小限制。



我们打开application.yml，在spring下面添加一下配置：

![image.png](https://pic.zhaotu.me/2023/03/01/image4aca905d343b84ef.png)

```java
servlet:
    multipart:
      enabled: true
      max-file-size: 10MB
      max-request-size: 10MB
```
然后重启项目，我们再次请求接口。

![image.png](https://pic.zhaotu.me/2023/03/01/image10d2f71cfb8b09e0.png)

看到了吧，有数据返回，这个就是我们刚才上传图片的地址，我们去查看一下，这个目录会自动创建的，是你项目当前路径下的地方，假如你的项目在D盘，则这个图片地址就会在D盘下面。

![image.png](https://pic.zhaotu.me/2023/03/01/imagea211f61635c79601.png)

看到了吧，我的项目就在D盘，所以这个文件就在D盘下。

接下来我们就要去实现前端的功能了，在这之前我们还要加一个图片拦截的操作，防止前端访问不到图片的操作。

新建一个配置类：MyInterceptorConfig.java，我放在了config包下。

```java
package com.blog.personalblog.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 这个是访问图片拦截的
 *
 * @author: SuperMan
 * @create: 2022-08-20
 **/
@Configuration
public class MyInterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/blog/uploadFile/articles/**")//前端url访问的路径，若有访问前缀，在访问时添加即可，这里不需添加。
                .addResourceLocations("file:/blog/uploadFile/articles/");//映射的服务器存放图片目录。
    }
}
```
还有一个再写前端之前，我们将上传图片的接口过滤掉，不受登录的限制，**还有个一图片预览的地址也要放开，否则请求图片地址会报302重定向错误这个是一个坑。**

**打开**ShiroConfiguration.java，再新增两个配置。

```java
filterChainDefinitionMap.put("/blog/uploadFile/articles/**","anon");
filterChainDefinitionMap.put("/article/upload", "anon");
```
接下来打开前端项目，我们来写前端上传图片的页面。
```vue
    	<el-form-item label="上传封面">
          <el-upload
            class="upload-cover"
            drag
            action="null"
            :http-request="importFile"
            multiple
            :before-upload="handleUploadBefore"
          >
            <i class="el-icon-upload" v-if="article.imageUrl == ''" />
            <div class="el-upload__text" v-if="article.imageUrl == ''">
              将文件拖到此处，或<em>点击上传</em>
            </div>
            <img
              v-else
              :src="article.imageUrl"
              width="360px"
              height="180px"
            />
          </el-upload>
      </el-form-item>
```
上边是上传图片的组件el-upload，这里面有几个注意点，大家可以看一下element官方文档，这里给大家说一下，在开发的过程中一定要去看开发文档，里面有很多的组件设置的属性，还有具体的使用方法。

我原来想使用组件自带的action直接使用上传的地址，但是测试了一下会出现跨域的问题，我们这个项目是统一走的api那边的路由，所以我直接换成了自定义上传的方式，我感觉自定义上传是的代码会更加的清晰，自定义上传的地址就要使用到**:http-request，这个文档也有说明。大家一定要看文档**

![image.png](https://pic.zhaotu.me/2023/03/01/image3b7b0af501be2ee6.png)

我们需要写两个方法，一个是图片上传的方法，另一个是图片上传之前进行验证的操作。

**以下是上传之前校验图片大小和格式**

```vue
handleUploadBefore(file) {
      const isJPGORPNG = file.type === "image/jpeg" || file.type === "image/png";
	    const isLt10M = file.size / 1024 / 1024 < 10;

	    if (!isJPGORPNG) {
	      this.$message.error('上传图片只能是 JPG 或 PNG 格式!');
	    }
	    if (!isLt10M) {
	      this.$message.error('上传图片大小不能超过 10MB!');
	    }
	    return isJPGORPNG && isLt10M;
},
```
图片上传接口请求。
```vue
importFile(param){
      let fd = new FormData();
      fd.append("file", param.file);  // 传文件
      uploadImg(fd).then(res => {
         if (res.data && res.data.code === 200) {
          this.$message({
            type: 'success',
            message: '图片上传成功!'
          })
         }
         this.article.imageUrl = res.data;
      })             
},
```
这个FormData实现form表单数据的序列化，将数据以键值对 name/value 的形式传到后台，从而减少表单元素的拼接，提高工作效率。

向FormData中添加新的属性值使用append，我们后端接收的参数就是file，所以我们添加一个file即可。

然后我们将上传图片的接口加入到接口中。在article.js接口中。

```vue
export function uploadImg(data) {
  return request({
    url: '/article/upload',
    method: 'post',
    data
  })
}
```
别忘了在import中引入该接口。

 好啦，这个上传的功能基本上实现了，我们测试一下，

![image.png](https://pic.zhaotu.me/2023/03/01/imaged2a3759fae7ffc62.png)

好啦，文章上传功能就这些，下面我们来写文章的发布功能。


### 3.4.6、保存草稿功能
这里需要修改一下文章的数据库，有一些字段需要修改，多的字段暂时就不删除了，不然就改动的很多。
```sql
DROP TABLE IF EXISTS `person_article`;
CREATE TABLE `person_article` (
  `id`             INT             NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键',
  `author`         VARCHAR(128)    NOT NULL                            COMMENT '作者',
  `title`          VARCHAR(255)    NOT NULL                            COMMENT '文章标题',
	`user_id`        INT(11)         NOT NULL                            COMMENT '用户id',
	`category_id`    INT(11)             NULL                            COMMENT '分类id',
	`content`        LONGTEXT        NOT NULL                            COMMENT '文章内容',
  `views`          BIGINT          NOT NULL DEFAULT 0                  COMMENT '文章浏览量',
	`total_words`    BIGINT          NOT NULL DEFAULT 0                  COMMENT '文章总字数',
  `commentable_id` INT    		         NULL                            COMMENT '评论id',
	`art_status`     TINYINT    	   NOT NULL DEFAULT 1                  COMMENT '发布，默认1, 1-发布, 2-仅我可见  3-草稿',
	`description`    VARCHAR(255)        NULL                            COMMENT '描述',
	`image_url`      VARCHAR(255)        NULL                            COMMENT '文章logo',
  `create_time`    DATETIME            NULL DEFAULT CURRENT_TIMESTAMP  COMMENT '创建时间',
  `update_time`    DATETIME            NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'
) ENGINE = InnoDB
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_bin
  ROW_FORMAT = Dynamic
  COMMENT '文章管理表';
```
还有文章和标签的关联表数据库也要修改一下，把表的id删除掉，这个字段多余的。
```sql
DROP TABLE IF EXISTS `person_article_tag`;
CREATE TABLE `person_article_tag` (
    `tag_id`		INT(11)           NOT NULL              COMMENT '标签id',
    `article_id`	INT(11)         NOT NULL              COMMENT '文章id'
) ENGINE = InnoDB
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_bin
  ROW_FORMAT = Dynamic
  COMMENT '文章和标签关联表';
```
**相对应的实体类和xml这两个文件要把id删除掉，这里我就不展示了，只删除id即可。**<br />保存草稿功能相对于保存文章比较简单，不需要进入到弹出框之前就结束了这个功能，先找到我们之前写的保存草稿页面，点击功能需要完善即可。这里就修改了一下点击的方法名称。
```vue
<el-button type="warning" 
      size="medium" 
      @click="saveDraft" 
      style="margin-left:10px" 
      v-if="article.id === '' || article.artStatus == 3"
>保存草稿</el-button>
```
接下来我们来实现saveDraft方法的功能。
```vue
saveDraft() {
      this.article.artStatus = 3;
      if (this.article.title.trim() == "") {
        this.$message.error("文章标题不能为空");
        return false;
      }
      if (this.article.content.trim() == "") {
        this.$message.error("文章内容不能为空");
        return false;
      }
      var body = this.article;
      addArticle(body).then(res => {
        if(res.code === 200) {
          this.$message({
            type: 'success',
            message: '保存草稿成功!'
          });
        } else {
          this.$message({
            type: 'error',
            message: '保存草稿失败!'
          });
        }
      })
},
```
从以上代码可以看出，我先校验了文章的标题和内容，然后调用了添加文章的接口进行文章保存。

这里还要修改一下文章保存的接口，我们之前设计的不太合理，现在需要再完善一下。

首先添加一个文章保存的对象：**ArticleInsertBO.java**

```java
package com.blog.personalblog.bo;

import lombok.Data;

/**
 * @author: SuperMan
 * @create: 2022-10-02
 */

@Data
public class ArticleInsertBO {
    /**
     * 文章id
     */
    private Integer id;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 分类id
     */
    private Integer categoryId;

    /**
     * 文章内容
     */
    private String content;

    /**
     * 发布，默认1, 1-发布, 2-仅我可见  3-草稿
     */
    private Integer artStatus;

    /**
     * 描述
     */
    private String description;

    /**
     * 文章logo
     */
    private String imageUrl;

    /**
     * 分类名称
     */
    private String categoryName;

     /**
     * 文章标签
     */
    private List<String> tagNameList;
}

```
然后修改接口，这里我将修改个添加整合到一个接口中，可以减少重复的代码
```java
	/**
     * 新建文章
     * @param bo
     * @return
     */
    void insertOrUpdateArticle(ArticleInsertBO bo);
```
分类还要新加一个根据分类名称查询分类的接口以及实现方法，我这里就直接把代码列出来，相信大家对这操作也都比较熟练了。
```java
	/**
     * 获取分类
     * @param categoryName
     * @return
     */
    Category getCategoryByName(String categoryName);
```
```java
    @Override
    public Category getCategoryByName(String categoryName) {
        Category category = categoryMapper.getCategoryByName(categoryName);
        return category;
    }
```
CategoryMapper.java:
```java

Category getCategoryByName(String categoryName);
```
```java
<select id="getCategoryByName" resultType="com.blog.personalblog.entity.Category">
    select * from person_category where category_name = #{categoryName, jdbcType=VARCHAR}
</select>
```
再将文章的发布形式单独提出来，写成一个枚举类，方便以后维护。
```java
package com.blog.personalblog.common;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * @author: SuperMan
 * @create: 2022-10-10
 **/

@Getter
@AllArgsConstructor
public enum ArticleArtStatusEnum {
    /**
     * 发布
     */
    PUBLISH(1, "发布"),
    /**
     * 仅我可见
     */
    ONLYME(2, "仅我可见"),
    /**
     * 草稿
     */
    DRAFT(3, "草稿");

    /**
     * 状态
     */
    private final Integer status;

    /**
     * 描述
     */
    private final String desc;
}

```
然后我们来写文章保存或修改的实现类。

这一块的逻辑相比较之前的有了一些变化，希望大家好好看一下这个逻辑，如果看不明白可以留言，我这里不再讲述了。

```java
    @Resource
    private CategoryService categoryService;
    @Resource
    private UserService userService;


    @Override
    public void insertOrUpdateArticle(ArticleInsertBO bo) {
        //分类添加
        Category category = saveCategory(bo);
        Article article = BeanUtil.copyProperties(bo, Article.class);
        if (category != null) {
            article.setCategoryId(category.getCategoryId());
        }
        String username = (String) SecurityUtils.getSubject().getPrincipal();
        User user = userService.getUserByUserName(username);
        article.setUserId(user.getId());
        article.setAuthor(user.getUserName());
		article.setViews(0L);
        article.setTotalWords(0L);
        if (bo.getId() != null) {
            articleMapper.updateArticle(article);
        } else {
            articleMapper.createArticle(article);
        }
        articleMap.put(article.getId(), article);
        //添加文章标签
        saveTags(bo, article.getId());

        //添加文章发送邮箱提醒
        try {
            String content = "【{0}】您好：\n" +
                    "您已成功发布了标题为: {1} 的文章 \n" +
                    "请注意查收！\n";
            MailInfo build = MailInfo.builder()
                    .receiveMail(user.getEmail())
                    .content(MessageFormat.format(content, user.getUserName(), article.getTitle()))
                    .title("文章发布")
                    .build();
            SendMailConfig.sendMail(build);
        } catch (Exception e) {
            log.error("邮件发送失败{}", e.getMessage());
        }

    }

    private Category saveCategory(ArticleInsertBO bo) {
        if (StrUtil.isEmpty(bo.getCategoryName())) {
            return null;
        }
        Category category = categoryService.getCategoryByName(bo.getCategoryName());
        if (category == null && !ArticleArtStatusEnum.DRAFT.getStatus().equals(bo.getArtStatus())) {
            category.setCategoryName(bo.getCategoryName());
            categoryService.saveCategory(category);
        }
        return category;
    }

    private void saveTags(ArticleInsertBO bo, Integer articleId) {
        //首先判断是不是更新文章
        if (bo.getId() == null) {
            articleTagService.deleteTag(bo.getId());
        }
        //添加文章标签
        List<String> tagNameList = bo.getTagNameList();
        List<Integer> tagIdList = new ArrayList<>();

        if (CollUtil.isNotEmpty(tagNameList)) {
            //先查看添加的标签数据库里有没有
            for (String tagName : tagNameList) {
                Tag one = tagService.findByTagName(tagName);
                if (one == null) {
                    Tag tag = new Tag();
                    tag.setTagName(tagName);
                    tagService.saveTag(tag);
                    tagIdList.add(tag.getId());
                } else {
                    tagIdList.add(one.getId());
                }
            }
        }
        articleTagService.deleteTag(articleId);
        if (tagIdList != null) {
            List<ArticleTag> articleTagList = tagIdList.stream().map(tagId -> ArticleTag.builder()
                    .tagId(tagId)
                    .articleId(articleId)
                    .build()).collect(Collectors.toList());
            articleTagService.insertBatch(articleTagList);
        }
    }
```
好啦，后端修改完成了，别忘了文章的数据库表更新成最新修改的。接下来我们运行项目，启动后端项目，然后我们测试一下数据有没有成功。

![image.png](https://pic.zhaotu.me/2023/03/01/imagea0ce73b55aee0b2c.png)

显示操作成功了，说明接口是通的，然后我们再去看一下数据库有没有这条数据。

![image.png](https://pic.zhaotu.me/2023/03/01/image9c03140f456dcf47.png)

有数据，那我们的保存草稿功能就完成了。


### 3.4.7、文章的发布状态
**文章的发布状态有三种：**

1. 公开
2. 自己可见
3. 草稿
```vue
<el-form-item label="发布形式">
    <el-radio-group v-model="article.artStatus">
      <el-radio :label="1">全部可见</el-radio>
      <el-radio :label="2">仅我可见</el-radio>
    </el-radio-group>
</el-form-item>
```

### 3.4.8、文章发布
前面已经将铺垫都准备好了，接下来我们还要实现一个发布的功能，这个和保存草稿的功能基本类似。
```vue
 handleSubmit() {
      this.showDialog = true;
      
      if (this.article.title.trim() == "") {
        this.$message.error("文章标题不能为空");
        return false;
      }
      if (this.article.content.trim() == "") {
        this.$message.error("文章内容不能为空");
        return false;
      }
      if (this.article.categoryName == null) {
        this.$message.error("文章分类不能为空");
        return false;
      }
       if (this.article.tagNameList.length == 0) {
        this.$message.error("文章标签不能为空");
        return false;
      }

      var body = this.article;
      addArticle(body).then(res => {
        if(res.code === 200) {
          this.$message({
            type: 'success',
            message: '文章发表成功!'
          });
        } else {
          this.$message({
            type: 'error',
            message: '文章发表失败!'
          });
        }
      })
},
```
写完之后，我们再测试一下正式发布文章。

![image.png](https://pic.zhaotu.me/2023/03/01/image9e1c97bf7c6c0195.png)

看到数据库有数据了，我们的文章发布功能就全部完成了。


# 4、列表
这个列表相信大家已经写了很多遍了，现在可以说大概的思路应该掌握在手，这里我对后端又进行了处理，以前的bug也修复了一些，我这里先把后端改的代码来说一下。

## 4.1、功能修改
**1、首先修改了根据分类id查找分类信息**

这里的改动不大，主要是改动了查询的sql语句。

```java
<select id="getById" resultMap="BaseResultMap">
    select * from person_category where category_id = #{categoryId, jdbcType=INTEGER}
</select>
```
**2、修改文章查询的接口，这里改动的稍微有点大。**

这边我把文章的标签给拆开了，减少了数据库查询的语句。

```java
	@Override
    @PostConstruct
    public void init() {
        List<Article> articleList = articleMapper.findAll();
        try {
            getTagsOrCategory(articleList);
            for(Article article : articleList) {
                articleMap.put(article.getId(), article);
            }
            log.info("文章缓存数据加载完成");
        } catch (Exception e) {
            log.error("文章缓存数据加载失败！", e.getMessage());
        }
    }

    @Override
    public List<Article> getArticlePage(ArticleBO articleBO) {
        int pageNum = articleBO.getPageNum();
        int pageSize = articleBO.getPageSize();
        PageHelper.startPage(pageNum,pageSize);
        List<Article> articleList = articleMapper.getArticlePage(articleBO);
        getTagsOrCategory(articleList);
        return articleList;
    }


    public void getTagsOrCategory(List<Article> list) {
        if (list != null) {
            for (Article article : list) {
                //查询分类
                Category category = categoryService.findById(article.getCategoryId());
                if (category == null) {
                    article.setCategoryName("无分类");
                } else {
                    article.setCategoryName(category.getCategoryName());
                }
                List<Tag> tagList = new ArrayList<>();
                List<ArticleTag> articleTags = articleTagService.findArticleTagById(article.getId());
                if (articleTags != null) {
                    for (ArticleTag articleTag : articleTags) {
                        Tag tag = tagService.findTagById(articleTag.getTagId());
                        tagList.add(tag);
                    }
                }
                article.setTagList(tagList);
            }
        }
    }
```
查询的接口如参要再包一层body
```java
   /**
     * 文章列表
     * @param articleBO
     * @return
     */
    @ApiOperation(value = "文章列表")
    @PostMapping("list")
    public JsonResult<Object> listPage(@RequestBody @Valid PageRequestApi<ArticleBO> articleBO) {
        List<Article> articleList = articleService.getArticlePage(articleBO.getBody());
        PageInfo pageInfo = new PageInfo(articleList);
        PageRequest pageRequest = new PageRequest();
        pageRequest.setPageNum(articleBO.getBody().getPageNum());
        pageRequest.setPageSize(articleBO.getBody().getPageSize());
        PageResult pageResult = PageUtil.getPageResult(pageRequest, pageInfo);
        return JsonResult.success(pageResult);
    }
```
ArticleBO.java类：
```java
package com.blog.personalblog.bo;

import lombok.Data;

/**
 * @author: SuperMan
 * @create: 2021-12-31
 */
@Data
public class ArticleBO {

    /**
     * 分类id
     */
    private Integer categoryId;

    /**
     * 发布，默认0, 0-发布, 1-草稿
     */
    private Integer artStatus;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 页码
     */
    private int pageNum;

    /**
     * 每页的数据条数
     */
    private int pageSize;
}

```
大家对以上的代码应该都能看的懂，我们再去修改一下xml文件。以下只是删掉了对标签的查询。
```java
    <resultMap id="BaseResultMap" type="com.blog.personalblog.entity.Article">
        <result column="id" jdbcType="INTEGER" property="id"/>
        <result column="author" jdbcType="VARCHAR" property="author"/>
        <result column="title" jdbcType="VARCHAR" property="title"/>
        <result column="user_id" jdbcType="INTEGER" property="userId"/>
        <result column="category_id" jdbcType="INTEGER" property="categoryId"/>
        <result column="content" jdbcType="VARCHAR" property="content"/>
        <result column="views" jdbcType="BIGINT" property="views"/>
        <result column="total_words" jdbcType="BIGINT" property="totalWords"/>
        <result column="commentable_id" jdbcType="INTEGER" property="commentableId"/>
        <result column="art_status" jdbcType="INTEGER" property="artStatus"/>
        <result column="description" jdbcType="VARCHAR" property="description"/>
        <result column="image_url" jdbcType="VARCHAR" property="imageUrl"/>
        <result column="create_time" jdbcType="TIMESTAMP" property="createTime"/>
        <result column="update_time" jdbcType="TIMESTAMP" property="updateTime"/>
        <result column="categoryname" jdbcType="VARCHAR" property="categoryName"></result>
    </resultMap>

<select id="getArticlePage" resultMap="BaseResultMap" parameterType="com.blog.personalblog.bo.ArticleBO">
        SELECT
        a.*,
        u.category_name categoryname
        FROM person_article a
        left JOIN person_category u on a.category_id = u.category_id
        <where>
            <if test="articleBO.title != null">
                and a.title like '%${articleBO.title}%'
            </if>
            <if test="articleBO.categoryId != null">
                and a.category_id = #{articleBO.categoryId}
            </if>
            <if test="articleBO.artStatus != null">
                and a.art_status = #{articleBO.artStatus}
            </if>
        </where>

    </select>
```
**3、根据文章id查找文章**

这个功能我根据前端的需要，重新写了一个返回类，用做编辑的时候数据回显的时候使用。

新增了了一个vo包，然后在包内新建一个**ArticleVO.java**

```java
package com.blog.personalblog.vo;

import com.blog.personalblog.entity.Tag;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

/**
 * @author: SuperMan
 * @create: 2022-10-10
 **/

@Data
public class ArticleVO {
    /**
     * 文章id
     */
    private Integer id;

    /**
     * 作者
     */
    private String author;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 用户id
     */
    private Integer userId;

    /**
     * 分类id
     */
    private Integer categoryId;

    /**
     * 文章内容
     */
    private String content;

    /**
     * 文章浏览量
     */
    private Long views;

    /**
     * 文章总字数
     */
    private Long totalWords;

    /**
     * 评论id
     */
    private Integer commentableId;

    /**
     * 发布，默认1, 1-发布, 2-仅我可见  3-草稿
     */
    private Integer artStatus;

    /**
     * 描述
     */
    private String description;

    /**
     * 文章logo
     */
    private String imageUrl;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    /**
     * 更新时间
     */
    private LocalDateTime updateTime;

    /**
     * 文章标签
     */
    private List<Tag> tagList;

    private List<String> tagNameList;

    /**
     * 分类名称
     */
    private String categoryName;
}

```
然后修改查询的接口
```java
    /**
     * 根据文章id查找文章
     * @param articleId
     * @return
     */
    ArticleVO findById(Integer articleId);
```
实现类：
```java
   @Override
   public ArticleVO findById(Integer articleId) {
        Article article = articleMap.get(articleId);

        ArticleVO articleVO = BeanUtil.copyProperties(article, ArticleVO.class);
        List<String> tagNameList = new ArrayList<>();
        if (articleVO != null) {
            if (articleVO.getTagList() != null) {
                for (Tag tag : articleVO.getTagList()) {
                    tagNameList.add(tag.getTagName());
                }
            }
        }
        articleVO.setTagNameList(tagNameList);
        articleVO.setCategoryName(article.getCategoryName());
        return articleVO;
    }
```
接口也要修改一下返回类。
```java
    /**
     * 根据文章id查找
     * @param id
     * @return
     */
    @ApiOperation(value = "根据文章id查找")
    @GetMapping("/getArticle/{id}")
    @OperationLogSys(desc = "根据文章id查找", operationType = OperationType.SELECT)
    public JsonResult<Object> getArticleById(@PathVariable(value = "id") int id) {
        ArticleVO article = articleService.findById(id);
        return JsonResult.success(article);
    }
```
基本上就修改了这几个地方，接下来开始写文章列表的页面。

首先在article.js文件中修改一下根据id获取文章的接口地址。

```vue
export function getArticleById(id){
  return request({
    url: '/article/getArticle/' + id,
    method: 'get'
  })
}
```
还有之前我们点击发布文章之后，没有返回到列表页，现在我们先添加上这个功能，只要在之前写的方法里添加上跳转的地址即可。添加这一句话：this.$router.push("/articles/list");
```vue
 var body = this.article;
      addArticle(body).then(res => {
        if(res.code === 200) {
          this.$notify({
              title: "文章发表成功",
              message: `文章《${this.article.title}》发表成功!`,
              type: "success",
          });
          this.$router.push("/articles/list");
        } else {
          this.$notify({
              title: "文章发表失败",
              message: `文章《${this.article.title}》发表失败！`,
              type: "error",
          });
        }
         this.showDialog = false;
     })
```
同时在发布草稿的方法里也要加上这一句。
```vue
  // ------- 保存草稿
    saveDraft() {
      this.article.artStatus = 3;
      if (this.article.title.trim() == "") {
        this.$message.error("文章标题不能为空");
        return false;
      }
      if (this.article.content.trim() == "") {
        this.$message.error("文章内容不能为空");
        return false;
      }
      var body = this.article;
      addArticle(body).then(res => {
        if(res.code === 200) {
          this.$message({
            type: 'success',
            message: '保存草稿成功!'
          });
          this.$router.push("/articles/list");
        } else {
          this.$message({
            type: 'error',
            message: '保存草稿失败!'
          });
        }
      })
    },
```

## 4.2、列表页面
页面和其他的列表差不多，这里我按照模块展示。<br />我先将return方法里的参数写出来。
```vue
data() {
    return {
      list: null,
      listLoading: true,
      count: 0,
      listQuery: {
        pageNum: 1,
        pageSize: 10,
        categoryId: null,
        artStatus: null,
        title: null
      },
      categoryId: null,
      categoryList: [],
      tagId: null,
      tagList: [],
      title: null,
      typeList: [
        {
          value: 1,
          label: "发布"
        },
        {
          value: 2,
          label: "仅我可见"
        },
        {
          value: 3,
          label: "草稿"
        }
      ],
      artStatus: null,
      views: null,
      totalWords: null,
      description: null
    }
  },
```
然后将接口导入进来
```vue
import { articleList, deleteArticle } from '@/api/article'
import { getCategory } from '@/api/category'
import { getTag } from '@/api/tag'
```
接着写页面功能。
```vue
    <!-- 设置标题文章管理 -->
    <div slot="header" class="clearfix">
      <span>文章列表</span>
    </div>
```

### 4.2.1、分类查询
废话不多说直接上代码，**完整代码再最后，可直接跳过看完整代码。**
```vue
     <!-- 文章分类 -->
        <el-select
          clearable
          size="small"
          v-model="categoryId"
          filterable
          placeholder="请选择分类"
          style="margin-right:1rem"
        >
          <el-option
            v-for="item in categoryList"
            :key="item.id"
            :label="item.categoryName"
            :value="item.categoryId"
          />
        </el-select>
```
这里遍历了categoryList，而这个list则是查询全部分类获取的，所以我们要写一个方法来查询分类，还要在页面初始的时候就要查询出来。接口还是那个添加文章的分类下拉的。
```vue
getCategoriesList() {
      var categoryName = "";
      getCategory({categoryName}).then(response => {
         this.categoryList = response.data;
      })
},
```
现在是有值了，然后再初始化页面的时候就加载完成。
```vue
  created() {
    this.getList();
    this.getCategoriesList();
  },
```
好啦，这时候可以看一下页面：

![image.png](https://pic.zhaotu.me/2023/03/01/imagee3b987cc0d83cff9.png)

### 4.2.2、文章类型查询
接下来我们再继续写文章的类型查询。
```vue
<!-- 文章类型 -->
  <el-select
    clearable
    v-model="artStatus"
    placeholder="请选择文章类型"
    size="small"
    style="margin-right:1rem"
    >
    <el-option
      v-for="item in typeList"
      :key="item.value"
      :label="item.label"
      :value="item.value"
    />
  </el-select>
```
typeList这个数据就是data方法中的数组，在上边已经列出来了
```vue
typeList: [
        {
          value: 1,
          label: "发布"
        },
        {
          value: 2,
          label: "仅我可见"
        },
        {
          value: 3,
          label: "草稿"
        }
],
```
![image.png](https://pic.zhaotu.me/2023/03/01/image86fd55b7fff59647.png)

同样也要在页面加载的时候一起加载数据，将方法也要放到created中

```vue
 created() {
    this.getList();
    this.getCategoriesList();
    this.getTagsList();
  },
```

### 4.2.3、文章标题查询
还有一个标题的搜索和点击搜索的按钮，当点击搜索的按钮触发查询的接口。
```vue
    	<!-- 文章名 -->
        <el-input
          clearable
          v-model="title"
          prefix-icon="el-icon-search"
          size="small"
          placeholder="请输入文章名"
          style="width:200px"
          @keyup.enter.native="searchArticles"
        />

        <el-button
          type="primary"
          size="small"
          icon="el-icon-search"
          style="margin-left:1rem"
          @click="searchArticles"
        >
          搜索
        </el-button>
```
这里用到了一个方法：searchArticles
```vue
searchArticles() {
  this.getList();
},
```
这里面又调用了getList方法
```vue
getList() {
      this.listLoading = true
      this.listQuery.categoryId = this.categoryId;
      this.listQuery.title = this.title;
      this.listQuery.artStatus = this.artStatus;

      var body = this.listQuery;
      articleList({body}).then(response => {
        this.list = response.data.result
        this.count = response.data.totalSize
        this.listLoading = false
      })
  },
```
下面可以写数据展示的表格了，这个没什么好说的，直接上代码
```vue
<el-table v-loading="listLoading" :data="list" fit highlight-current-row style="width: 98%; margin-top:30px;">
      <el-table-column align="center" label="ID" >
        <template slot-scope="scope">
          <span>{{ scope.row.id }}</span>
        </template>
      </el-table-column>

      <el-table-column label="文章封面" width="180" align="center">
        <template slot-scope="scope">
          <img
            class="article-cover"
            :src=" scope.row.imageUrl" />
        </template>
      </el-table-column>

      <!-- 文章标题 -->
      <el-table-column prop="title" label="标题" align="center" />

      <!-- 文章分类 -->
      <el-table-column prop="categoryName" label="分类" width="110" align="center"/>

      <!-- 文章标签 -->
      <el-table-column prop="tagList" label="标签" width="170" align="center">
        <template slot-scope="scope">
          <el-tag
            v-for="item of scope.row.tagList"
            :key="item.id"
            style="margin-right:0.2rem;margin-top:0.2rem"
          >
            {{ item.tagName }}
          </el-tag>
        </template>
      </el-table-column>

      <!-- 文章浏览量 -->
      <el-table-column
        prop="views"
        label="浏览量"
        width="70"
        align="center"
      >
        <template slot-scope="scope">
          <span v-if="scope.row.views">
            {{ scope.row.views }}
          </span>
          <span v-else>0</span>
        </template>
      </el-table-column>
      <!-- 文章总字数 -->
      <el-table-column
        prop="totalWords"
        label="总字数"
        width="70"
        align="center"
      >
        <template slot-scope="scope">
          <span v-if="scope.row.totalWords">
            {{ scope.row.totalWords }}
          </span>
          <span v-else>0</span>
        </template>
      </el-table-column>

      <!-- 文章描述 -->
      <el-table-column prop="description" label="描述" align="center" />

      <el-table-column align="center" label="操作" width="180">
        <template slot-scope="scope">
          <el-button type="primary" size="mini" icon="el-icon-edit" @click="editArticle(scope.row.id)">编辑</el-button>
          <el-button type="danger" size="small" icon="el-icon-delete" @click="deleteArticleById(scope.row.id)" >删除</el-button>
        </template>
      </el-table-column>

    </el-table>

    <!-- 分页 -->
    <el-pagination
      class="pagination-container"
      background
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="this.listQuery.pageNum"
      :page-size="this.listQuery.pageSize"
      :total="count"
      :page-sizes="[10, 20, 30]"
      layout="total, sizes, prev, pager, next, jumper"
    />
```
方法：
```vue
 handleSizeChange(pageSize) {
      this.listQuery.pageSize = pageSize
      this.getList()
    },
 handleCurrentChange(pageNum) {
      this.listQuery.pageNum = pageNum
      this.getList()
  },
```
以上就是展示的功能，下面我们来写删除和编辑的，这个就比较简单了，和之前的基本上一样。

# 5、删除 
删除后端的接口传的参数格式做了修改，我记得没有写。这里我先写出来，大家如果没有更改就修改一下，如果修改了就过掉。
```java
	/**
     * 删除文章
     * @return
     */
    @ApiOperation(value = "删除文章")
    @DeleteMapping("/delete")
    @OperationLogSys(desc = "删除文章", operationType = OperationType.DELETE)
    public JsonResult<Object> articleDelete(@RequestParam(value = "id") int id) {
        articleService.deleteArticle(id);
        return JsonResult.success();
    }
```
前端接口：
```vue
export function deleteArticle(id) {
  return request({
    url: '/article/delete',
    method: 'delete',
    params: { id }
  })
}
```
删除的方法：
```vue
 deleteArticleById (id) {
      this.$confirm('此操作将永久删除该文章, 是否继续?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        deleteArticle(id).then(response => {
           this.$message({
            type: 'success',
            message: '删除成功!'
          })
           this.getList()
        }).catch(() => {
          console.log('error')
        })
      }).catch(() => {
         this.$message({
            type: 'error',
            message: '你已经取消删除该文章！'
          })
      })
    },

```
这里没啥好说的，和之前的删除操作基本上一样。

# 6、修改功能
修改功能稍微做了一点的改变，我们看一下表格的操作栏的编辑按钮
```vue
<el-button type="primary" size="mini" icon="el-icon-edit" @click="editArticle(scope.row.id)">编辑</el-button>
```
点击时间绑定了一个方法，我们要传入文章的id
```vue
 editArticle(id) {
      this.$router.push({ name: 'Addrticles', params: { id: id }});
  },
```
这个和之前的公告差不多，只是将这个跳转提取到了方法内实现。

相对应的，在add页面中进行接收。

```vue
  created() {
    const id = this.$route.params.id;
    if(id) {
      getArticleById(id).then((res) => {
        
        console.log(res.data)
        this.article = res.data;
      });
    }
  },
```
这是编辑的功能也修改好了。

![image.png](https://pic.zhaotu.me/2023/03/01/image387646c82541662d.png)

看着还可以，大家可以自己美化一下页面，到这里文章的所有功能基本上全部完成了。

以下是列表的全部代码：

```vue
<template>
    <el-card class="box-card">

    <!-- 设置标题文章管理 -->
    <div slot="header" class="clearfix">
      <span>文章列表</span>
    </div>

    <!-- 文章按条件查找 -->
     <div style="margin-left:auto">
       <!-- 文章分类 -->
        <el-select
          clearable
          size="small"
          v-model="categoryId"
          filterable
          placeholder="请选择分类"
          style="margin-right:1rem"
        >
          <el-option
            v-for="item in categoryList"
            :key="item.id"
            :label="item.categoryName"
            :value="item.categoryId"
          />
        </el-select>
        <!-- 文章类型 -->
        <el-select
          clearable
          v-model="artStatus"
          placeholder="请选择文章类型"
          size="small"
          style="margin-right:1rem"
        >
          <el-option
            v-for="item in typeList"
            :key="item.value"
            :label="item.label"
            :value="item.value"
          />
        </el-select>
        <!-- 文章名 -->
        <el-input
          clearable
          v-model="title"
          prefix-icon="el-icon-search"
          size="small"
          placeholder="请输入文章名"
          style="width:200px"
          @keyup.enter.native="searchArticles"
        />

        <el-button
          type="primary"
          size="small"
          icon="el-icon-search"
          style="margin-left:1rem"
          @click="searchArticles"
        >
          搜索
        </el-button>
     </div>

    <el-table v-loading="listLoading" :data="list" fit highlight-current-row style="width: 98%; margin-top:30px;">
      <el-table-column align="center" label="ID" >
        <template slot-scope="scope">
          <span>{{ scope.row.id }}</span>
        </template>
      </el-table-column>

      <el-table-column label="文章封面" width="180" align="center">
        <template slot-scope="scope">
          <img
            class="article-cover"
            :src=" scope.row.imageUrl" />
        </template>
      </el-table-column>

      <!-- 文章标题 -->
      <el-table-column prop="title" label="标题" align="center" />

      <!-- 文章分类 -->
      <el-table-column prop="categoryName" label="分类" width="110" align="center"/>

      <!-- 文章标签 -->
      <el-table-column prop="tagList" label="标签" width="170" align="center">
        <template slot-scope="scope">
          <el-tag
            v-for="item of scope.row.tagList"
            :key="item.id"
            style="margin-right:0.2rem;margin-top:0.2rem"
          >
            {{ item.tagName }}
          </el-tag>
        </template>
      </el-table-column>

      <!-- 文章浏览量 -->
      <el-table-column
        prop="views"
        label="浏览量"
        width="70"
        align="center"
      >
        <template slot-scope="scope">
          <span v-if="scope.row.views">
            {{ scope.row.views }}
          </span>
          <span v-else>0</span>
        </template>
      </el-table-column>
      <!-- 文章总字数 -->
      <el-table-column
        prop="totalWords"
        label="总字数"
        width="70"
        align="center"
      >
        <template slot-scope="scope">
          <span v-if="scope.row.totalWords">
            {{ scope.row.totalWords }}
          </span>
          <span v-else>0</span>
        </template>
      </el-table-column>

      <!-- 文章描述 -->
      <el-table-column prop="description" label="描述" align="center" />

      <el-table-column align="center" label="操作" width="180">
        <template slot-scope="scope">
          <el-button type="primary" size="mini" icon="el-icon-edit" @click="editArticle(scope.row.id)">编辑</el-button>
          <el-button type="danger" size="small" icon="el-icon-delete" @click="deleteArticleById(scope.row.id)" >删除</el-button>
        </template>
      </el-table-column>

    </el-table>

    <!-- 分页 -->
    <el-pagination
      class="pagination-container"
      background
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="this.listQuery.pageNum"
      :page-size="this.listQuery.pageSize"
      :total="count"
      :page-sizes="[10, 20, 30]"
      layout="total, sizes, prev, pager, next, jumper"
    />

    </el-card>
</template>

<script>

import { articleList, deleteArticle } from '@/api/article'
import { getCategory } from '@/api/category'
import { getTag } from '@/api/tag'

export default {
  name: 'articleList',

  created() {
    this.getList();
    this.getCategoriesList();
    this.getTagsList();
  },

  data() {
    return {
      list: null,
      listLoading: true,
      count: 0,
      listQuery: {
        pageNum: 1,
        pageSize: 10,
        categoryId: null,
        artStatus: null,
        title: null
      },
      categoryId: null,
      categoryList: [],
      tagId: null,
      tagList: [],
      title: null,
      typeList: [
        {
          value: 1,
          label: "发布"
        },
        {
          value: 2,
          label: "仅我可见"
        },
        {
          value: 3,
          label: "草稿"
        }
      ],
      artStatus: null,
      views: null,
      totalWords: null,
      description: null
    }
  },

  methods: {

    getList() {
      this.listLoading = true
      this.listQuery.categoryId = this.categoryId;
      this.listQuery.title = this.title;
      this.listQuery.artStatus = this.artStatus;

      var body = this.listQuery;
      articleList({body}).then(response => {
        this.list = response.data.result
        this.count = response.data.totalSize
        this.listLoading = false
      })
    },

    editArticle(id) {
      this.$router.push({ name: 'Addrticles', params: { id: id }});
    },

    getCategoriesList() {
      var categoryName = "";
      getCategory({categoryName}).then(response => {
         this.categoryList = response.data;
      })
    },

    getTagsList() {
      var tagName = "";
      getTag({tagName}).then(response => {
         this.tagList = response.data;
      })
    },

    searchArticles() {
      this.getList();
    },

    handleSizeChange(pageSize) {
      this.listQuery.pageSize = pageSize
      this.getList()
    },
    handleCurrentChange(pageNum) {
      this.listQuery.pageNum = pageNum
      this.getList()
    },


    deleteArticleById (id) {
      this.$confirm('此操作将永久删除该文章, 是否继续?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        deleteArticle(id).then(response => {
           this.$message({
            type: 'success',
            message: '删除成功!'
          })
           this.getList()
        }).catch(() => {
          console.log('error')
        })
      }).catch(() => {
         this.$message({
            type: 'error',
            message: '你已经取消删除该文章！'
          })
      })
    },

  },

 
}
</script>

<style rel="stylesheet/scss" lang="scss" scoped>
  .pagination-container {
    float: right;
    margin-top: 1.25rem;
    margin-bottom: 1.25rem;
  }
  .box-card {
    width: 98%;
    margin: 1%;
  }
  .clearfix:before,
  .clearfix:after {
    display: table;
    content: "";
  }
  .clearfix:after {
    clear: both
  }
  .clearfix span {
    font-weight: 600;
  }
  .article-cover {
    position: relative;
    width: 100%;
    height: 90px;
    border-radius: 4px;
  }
  .article-cover::after {
    content: "";
    background: rgba(0, 0, 0, 0.3);
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
  }

</style>

```

# 7、总结
目前为止我们这个全部的功能已经基本上实现了，现在我们接下来要美化一下我们的系统，大家也发现当登录进来的首页还是空的，登录页面也比较的单调丑陋，所以可能还需要一篇来扩展一下我们的系统，可能也是最后一篇了。

关于项目的发布，不知道还要不要写，项目在linux上所需要的环境搭建，我会放到我的公众号上，这里不再写搭建的内容，这里征求一下意见，如果有需要我就写一下或者直接私信我，没有我就不再写了，这个项目就完结了。





